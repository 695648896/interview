// 标记清除算法(Mark-Sweep)
// 1. 垃圾收集器在运行时会给内存中的所有变量都加上一个标记,假设内存中所有对象都是垃圾,全标记为0
// 2. 然后从各个根对象开始遍历,把不是垃圾的节点改成1
// 3. 清理所有标记为0的垃圾,销毁并回收它们所占用的内存空间
// 4. 最后,把所有内存中对象标记修改为0,等待下一轮垃圾回收
// 优点: 实现简单, 缺点: 内存碎片化(清除之后剩余的对象位置不变而导致的空闲内存不连续), 分配速度慢(需要遍历剩余内存碎片,寻找可以放置对象的合适内存碎片)
// 缺点可通过标记整理(Mark-Compact)算法来解决,它的标记阶段和标记清除算法没有什么不同,只是标记结束后,标记整理算法会将活着的对象(即不需要清理的对象)向内存的一端移动,最后清理掉边界的内存



// 引用计数算法(Reference Counting) 它把[对象是否不再需要]简化定义为[对象有没有其他对象引用它],如果没有引用指向该对象(零引用),对象将被垃圾回收机制回收,目前很少使用这种算法了,因为它的问题很多,不过我们还是需要了解一下
// 它的策略是跟踪记录每个变量值被使用的次数
// 1. 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为1
// 2. 如果同一个值又被赋给另一个变量,那么引用次数加1
// 3. 如果该变量的值被其他的值覆盖了,则引用次数减1
// 4. 当这个值的引用次数变为0的时候,说明没有变量在使用,这个值没法被访问了,回收空间,垃圾回收器会在运行的时候清理掉引用次数为0的值占用的内存
// 优点:引用计数为0时可以立即回收,  缺点: 需要计数器-计数器需要占很大位置,循环引用-导致引用数量不为0,造成大量的内存不会被释放 

// V8对GC的优化 


// 分代式垃圾回收 V8中将堆内存分为新生代和老生代两区域,采用不同的垃圾回收器也就是不同的策略管理垃圾回收
// 新生代的对象为存活时间较短的对象,简单来说就是新产生的对象,通常只支持1~8M
// 老生代的对象为存活时间较长或常驻内存的对象,简单来说就是经历过新生代垃圾回收后还存活下来的对象,容量通常比较大

// 新生代垃圾回收
// 新生代对象是通过一个名为Scavenge的算法进行垃圾回收,在Scavenge算法的具体实现中,主要采用了一种复制式的方法即Cheney算法
// Cheney算法中将堆内存一份为二,一个是处于使用状态的空间我们暂且称之为使用区,一个是处于闲置状态的空间我们称之为空闲区
// 1. 新加入的对象都会放到使用区,当使用区快被写满时,就需要执行一次垃圾清理操作
// 2. 当开始进行垃圾回收时,新生代垃圾回收器会对使用区中的活动对象做标记,标记完成之后将使用区的活动对象复制进空闲区并进行排序,随后进入垃圾清理阶段,即将非活动对象占用的空间清理掉.最后进行角色互换,把原来的使用区变成空闲区,把原来的空闲区变成使用区
// 3. 当一个对象经过多次复制后依然存活,它将会被认为是生命周期较长的对象,随后会被移动到老生代中,采用老生代的垃圾回收策略进行管理
// 4. 另外还有一种情况,如果复制一个对象到空闲区时,空闲区空间占用超过了25%,那么这个对象会被直接晋升到老生代空间中,设置为25%的比例的原因是,当完成Scavenge回收后,空闲区将翻转成使用区,继续进行对象内存的分配,若占比过大,将会影响后续分配

// 老生代垃圾回收
// 由于老生代中的对象通常比较大,如果再如新生代一般分区然后复制翻转会非常耗时,从而导致回收执行效率不高,所以老生代垃圾回收器来管理其垃圾回收执行,它的整个流程就采用的就是标记清除法
// 1. 首先是标记阶段,从一组根元素开始,递归遍历这组根元素,遍历过程中能达到的元素称为活动对象,没有达到的元素就可以判断为非活动对象
// 2. 清除阶段老生代垃圾回收器会直接将非活动对象,也就是数据清理掉
// 3. 清除后会产生大量不连续的内存碎片,V8中通过上文说的标记整理算法(Mark-Compact)来优化空间

// 为什么需要分代式?
// 分代式机制把一些新、小、存活时间短的对象作为新生代,采用一小块内存频率较高的快速清理,而一些大、老、存活时间长的对象作为老生代,使其很少接受检查,新老生代的回收机制及频率是不同的,可以说此机制的出现很大程度提高了垃圾回收机制的效率



// 并行回收(Parallel)
// JS是一门单线程的语言,它是运行在主线程上的,那在进行垃圾回收时就会阻塞JS脚本的执行,需等待垃圾回收完毕后再执恢复脚本执行,我们把这种行为叫做全停顿(Stop-The-World)
// V8团队引入了并行回收机制, 新生代对象空间就采用并行策略,在执行垃圾回收的过程中,会启动了多个线程来负责新生代中的垃圾清理操作,这些线程同时将对象空间的数据移动到空闲区域,这个过程中由于数据地址会发生改变,所以还需要同步更新引用这些对象的指针,此即并行回收

// 增量标记与懒性清理

// 上面所说的并行策略可以增加垃圾回收的效率,但还是全停顿的方式,对于老生代来说,依然可能消耗大量时间,为了减少全停顿的时间,在2011年,V8对老生代的标记进行了优化,从全停顿切换到增量标记
// 什么是增量
// 增量就是将一次GC标记的过程分成了很多小步,每执行一小步就让应用逻辑执行一会儿,这样交替多次后完成一轮GC标记
// 试想一下,将一次完整的GC标记分次执行,那在每一小次GC标记执行完之后如何暂停下来去执行任务程序,而后又怎么恢复呢?那假如我们再一次完整的GC标记分块暂停后,执行任务程序时内存中标记好的对象引用关系被修改了又怎么办呢?
// 可以看出增量的实现比并行复杂,V8对这两个问题对应的解决方案分别是三色标记法与写屏障
// 三色标记法(暂停与恢复)
// 在采用增量算法之前,单纯使用黑色和白色来标记数据就可以了,其标记流程即在执行一次完整的GC标记前,垃圾回收器会将所有的数据置为白色,然后垃圾回收器在会从一组根对象出发,将所有能访问到的数据标记为黑色,遍历结束之后,标记为黑色的数据对象就是活动对象,剩余的白色数据对象也就是待清理的垃圾对象
// 如果采用非黑即白的标记策略,那进行增量回收时,这时候内存中黑白色对象都有,我们无法得知下一步走到哪里 为了解决这个问题 V8团队采用了一种特殊方式: 
// 三色标记法

// 三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记,两个标记位编码三种颜色: 白、灰、黑
// 白色指的是未被标记的对象
// 灰色指自身被标记,成员变量(该对象的引用对象)未被标记
// 黑色指自身和成员变量皆被标记
// 我们用最简单的表达方式来解释这一过程，最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色
// 就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收
// 采用三色标记法后我们在恢复执行时就好办多了,可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成,如果没有灰色节点,直接进入清理阶段,如还有灰色标记,恢复时直接从灰色的节点开始继续执行就可以
// 优点: 三色标记法的mark操作可以渐进执行的而不需要每次都扫描整个内存空间,可以很好的配合增量回收进行暂停恢复的一些操作,从而减少全停顿的时间

// 写屏障 Write-barrier机制(增量中修改引用)
// 即一旦有黑色对象引用白色对象,该机制会强制将引用的白色对象改为灰色,从而保证下一次增量GC标记阶段可以正确标记,这个机制也被称为强三色不变性

// 懒性清理
// 增量标记其实只是对活动对象和非活动对象进行标记,对于真正的清理释放内存V8采用的是惰性清理(Lazy Sweeping)
// 增量标记完成后,惰性清理就开始了.当增量标记完成后,假如当前的可用内存足以让我们快速的执行代码,其实我们是没必要立即清理内存的,可以将清理过程稍微延迟,让JS脚本代码限制性,

// 增量标记与惰性清理的优缺点
// 优点: 减少全停顿时间, 却敌爱你:没有减少主线程总暂停时间,甚至会略微增加,其次由于写屏障的成本,增量标记可能会降低应用程序的吞吐量

// 并发回收(Concurrent)
// 它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起

// 再说V8中GC优化
// V8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器用的哪个策略呢？
// 上面说了并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验
// 其实，这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的
// 老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）
// 标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）
// 同时，清理的任务会采用增量的方式分批在各个 JavaScript 任务之间执行